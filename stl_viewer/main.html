<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STL Viewer – Scenic</title>
  <style>
    /* Fullscreen canvas with a soft gradient background */
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 800px at 70% 20%, #2a2f3a 0%, #151821 55%, #0e1117 100%);
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 12px; bottom: 12px; color: #c7d2fe; opacity:.8; font-size:12px; user-select:none; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">drag per ruotare • wheel per zoom • right-drag per pan</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';
    import { STLLoader } from 'https://unpkg.com/three@0.159.0/examples/jsm/loaders/STLLoader.js';
    import { RoomEnvironment } from 'https://unpkg.com/three@0.159.0/examples/jsm/environments/RoomEnvironment.js';

    // === CONFIG ===
    const MODEL_URL = new URLSearchParams(location.search).get('stl') || './stl_viewer/targhetta_diego.stl';

    // === SCENE SETUP ===
    const app = document.getElementById('app');
    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    app.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 2000);
    camera.position.set(1.2, 0.9, 1.4);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true; // look alive ✨
    controls.autoRotateSpeed = 0.6;

    // Subtle HDRI-like environment for nice reflections
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.03).texture;

    // Key / fill lights + soft rim
    const hemi = new THREE.HemisphereLight(0xbfd4ff, 0x1c222b, 0.6);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(3, 4, 2); key.castShadow = true; key.shadow.mapSize.set(1024,1024); scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.4); fill.position.set(-2, 2, -3); scene.add(fill);

    // Ground with soft shadow receiver
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), groundMat);
    ground.rotation.x = -Math.PI/2; ground.position.y = 0; ground.receiveShadow = true; scene.add(ground);

    // Faint grid that fades with distance
    const grid = new THREE.GridHelper(40, 40, 0x445175, 0x242b3a);
    grid.material.opacity = 0.18; grid.material.transparent = true; grid.position.y = 0.001; // avoid z-fighting
    scene.add(grid);

    function onResize(){
      const w = app.clientWidth, h = app.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    addEventListener('resize', onResize);

    const loader = new STLLoader();
    let mesh, edges;

    function placeOnGroundAndCenter(geometry){
      geometry.computeBoundingBox();
      const bb = geometry.boundingBox; // Box3
      const size = new THREE.Vector3(); bb.getSize(size);
      const center = new THREE.Vector3(); bb.getCenter(center);
      // translate so minY -> 0 and center XZ to origin
      geometry.translate(-center.x, -bb.min.y, -center.z);
      return { size };
    }

    function frameCameraBySize(size){
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const dist = maxDim / Math.tan(fov/2) * 1.2; // a bit farther for comfort
      camera.position.set(dist*0.8, dist*0.6, dist*0.8);
      camera.near = Math.max(dist*0.001, 0.01);
      camera.far  = dist*10;
      camera.updateProjectionMatrix();
      controls.target.set(0, size.y*0.5, 0);
      controls.update();
      // Move ground to Y=0 under model
      ground.position.y = 0;
    }

    function showGeometry(geometry){
      if (mesh){ scene.remove(mesh); mesh.geometry.dispose(); }
      if (edges){ scene.remove(edges); edges.geometry.dispose(); }
      if (!geometry.attributes.normal) geometry.computeVertexNormals();

      const { size } = placeOnGroundAndCenter(geometry);
      frameCameraBySize(size);

      const material = new THREE.MeshPhysicalMaterial({
        color: 0x9bb4ff,
        roughness: 0.35,
        metalness: 0.05,
        clearcoat: 0.3,
        clearcoatRoughness: 0.4,
        envMapIntensity: 1.0
      });

      mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      scene.add(mesh);

      // Crisp edges overlay for a CAD feel
      const egeom = new THREE.EdgesGeometry(geometry, 1);
      edges = new THREE.LineSegments(egeom, new THREE.LineBasicMaterial({ color: 0x495a84, transparent:true, opacity:0.45 }));
      edges.position.copy(mesh.position);
      scene.add(edges);

      onResize();
    }

    loader.load(MODEL_URL, (geo)=>{
      try{ showGeometry(geo); } catch(err){ console.error(err); }
    }, undefined, (e)=>{
      console.error('Caricamento STL fallito:', e);
    });

    onResize();
    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>